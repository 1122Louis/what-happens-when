What happens when...
====================

This repository is an attempt to answer the age-old interview question "What
happens when you type google.com into your browser's address box and press
enter?"

Except instead of the usual story, we're going to try to answer this question
in as much detail as possible. No skipping out on anything.

This is a collaborative process, so dig in and try to help out! There are tons
of details missing, just waiting for you to add them! So send us a pull
request, please!

This is all licensed under the terms of the `Creative Commons Zero`_ license.

Read this in `简体中文`_ (simplified Chinese), `日本語`_ (Japanese), `한국어`_
(Korean) and `Spanish`_. NOTE: these have not been reviewed by the alex/what-happens-when
maintainers.

Table of Contents
====================

.. contents::
   :backlinks: none
   :local:

The "g" key is pressed
----------------------
When you press the "g" key on your computer keyboard, it sets off a sequence of intricate actions, involving the physical keyboard and the operating system (OS) of your device. This article will comprehensively explain the key events that transpire as a result of pressing the "g" key and how web browsers handle this input.

Physical Keyboard Action
Pressing the "g" key on your keyboard is a seemingly simple physical action, but it initiates a cascade of events in your computer. Let's explore what happens when you press this key in more detail:

Keyboard Signal Generation
Key Press Event: The action begins when you press the "g" key. This press is registered as an electrical signal, which is then transformed into a digital signal by the keyboard's microcontroller.

USB/HID Communication: The digital signal is transmitted to your computer via USB or another Human Interface Device (HID) protocol, allowing the OS to recognize the key press.

OS Interrupts
Event Propagation
The first step in the process is the generation of an OS interrupt by the keyboard driver. This interrupt signals to the operating system that a key has been pressed. The OS is responsible for handling this interrupt and passing the information to the appropriate application, in this case, your web browser.

Browser's Response
Event Handling in the Browser
Upon receiving the key press event from the OS, the web browser processes it. The "g" key event triggers various actions in the browser, with one of the most common responses being auto-complete suggestions.

Auto-Complete Functionality
When you press the "g" key, the browser typically receives the event and triggers its auto-complete functionality. This feature is designed to assist users by suggesting relevant search queries, URLs, or previously visited websites that start with "g."

Suggestion Algorithms
The suggestions that appear in the dropdown below the URL bar are generated by the browser's auto-complete algorithm. The exact behavior can vary between browsers, and it may also depend on whether you are browsing in a regular mode or in private/incognito mode.

Algorithm Factors
Search History: The browser may consider your search history when suggesting completions, prioritizing websites or queries you've previously visited or searched for.

Bookmarks: If you have bookmarked websites that start with "g," they might be prioritized in the suggestions, offering quick access to your favorite sites.

Cookies: Information stored in cookies can influence the suggestions, potentially tailoring them based on your past interactions with websites.

Popular Searches: Common search terms and popular websites starting with "g" may also play a role in influencing the suggestions presented.

Real-Time Suggestions
As you type "google.com" after pressing the "g" key, the browser's auto-complete feature continues to run in real-time. With each keypress, it refines its suggestions. It may even suggest "google.com" before you finish typing the entire address, offering the most likely completion based on your previous browsing habits.

The "enter" key bottoms out
---------------------------

When the "Enter" key is pressed, a series of intricate actions are set in motion, ranging from the electrical signaling to data transmission:

Electrical Signal Generation
Keypress Event: When you press the "Enter" key, you engage in a physical action. This press generates an electrical signal that represents the closure of the key's circuit. This closure can be achieved either directly (by a physical connection) or capacitively (through the interaction of the key with the keyboard's capacitive sensors).

Current Flow: This closure allows a small amount of electric current to flow into the logic circuitry of the keyboard. This current is used to power and trigger further actions within the keyboard.

Keyboard Switch State Scanning
Scanning Key Switches: The logic circuitry of the keyboard is designed to scan the state of each key switch. In this case, when the "Enter" key is closed, it's detected by the keyboard controller.

Debouncing: Key switches are notorious for producing electrical noise when rapidly opened and closed. To counter this, the keyboard's logic circuitry debounces the electrical signal, filtering out the noise to ensure accurate and stable detection of keypresses.

Keycode Generation: After debouncing, the keyboard controller converts the "Enter" key's closure to a specific keycode integer. In this case, "Enter" is commonly associated with the keycode 13. This keycode serves as a unique identifier for the "Enter" key.

Keyboard Controller and Data Transmission
Keycode Encoding: The keyboard controller encodes the keycode (in this case, 13 for "Enter") for transmission to the computer. Encoding involves converting the numeric identifier into a format that the computer can understand.

Transport to Computer: The encoded keycode is then sent to the computer. This communication is typically achieved over a Universal Serial Bus (USB) or a Bluetooth connection in modern systems. Historically, other connections like PS/2 (Personal System/2) or ADB (Apple Desktop Bus) were used, depending on the type of keyboard and computer.

*In the case of the USB keyboard:*
USB Power Supply: The USB circuitry of the keyboard is powered by the 5V supply provided over pin 1 from the computer's USB host controller. This power supply ensures the keyboard's internal circuitry and logic are operational.

Keycode Storage: The keycode generated by pressing the "Enter" key is stored within the keyboard's internal circuitry memory. This keycode is placed in a register known as the "endpoint." The "endpoint" serves as a temporary storage location for the keycode until it is ready to be transmitted.

USB Data Transmission
Polling by Host USB Controller: The host USB controller of the computer periodically polls the "endpoint" within the keyboard approximately every 10 milliseconds, as dictated by the keyboard's minimum polling rate. This polling frequency ensures that the computer stays up to date with any keypresses.

USB Packet Conversion: When the host USB controller polls the "endpoint," it retrieves the keycode stored there. This value is then sent to the USB Serial Interface Engine (SIE) to be converted into one or more USB packets. These packets adhere to the low-level USB protocol.

Differential Signal Transmission: The USB packets are transmitted from the keyboard to the computer over the USB connection. This transmission occurs via the D+ and D- pins (the middle two pins of the USB connector). USB devices, like keyboards, are typically categorized as "low-speed devices," complying with USB 2.0 specifications. They transmit data at a maximum speed of 1.5 Mb/s using differential electrical signals.

Signal Decoding at Host USB Controller: At the computer's host USB controller, the differential signal received over the D+ and D- pins is decoded. This decoding process is crucial in understanding the data sent by the keyboard.

Operating System Interaction
Interpretation by HID Driver: The decoded signal is then interpreted by the computer's Human Interface Device (HID) universal keyboard device driver. This driver is responsible for translating the raw data into recognizable keyboard events, such as the "Enter" keypress.

Operating System Integration: The value of the key, in this case, the "Enter" key, is then passed into the operating system's hardware abstraction layer. This integration with the operating system allows the keypress to trigger specific actions, such as submitting a form or moving to a new line in a document.

*In the case of Virtual Keyboard (as in touch screen devices):*
Capacitive Touch Screen
User Interaction: When a user touches a modern capacitive touch screen, a tiny amount of electrical current is transferred to their finger. This phenomenon completes a circuit through the electrostatic field of the touch screen's conductive layer, creating a voltage drop at the point of contact.

Screen Controller: The touch screen is equipped with a "screen controller" responsible for monitoring touch events. When a voltage drop occurs due to the user's touch, the screen controller registers this change and raises an interrupt.

Interrupt Generation: The interrupt raised by the screen controller includes the coordinates of the touch event. These coordinates indicate the precise location on the screen where the touch occurred.

Mobile Operating System
Operating System Handling: The mobile operating system (OS) plays a critical role in the process. It constantly monitors for hardware events, including touch screen interrupts.

GUI Element Event: When the OS detects a touch event on the screen, it notifies the currently focused application, which may be the virtual keyboard application in this case. The application is informed that a press event has occurred within one of its GUI elements, such as a virtual keyboard button.

Virtual Keyboard Application
Virtual Keyboard Interaction: With the knowledge of the touch event, the virtual keyboard application can now respond. It can raise a software interrupt to send a "key pressed" message back to the mobile OS.

Software Interrupt: This software interrupt serves as a notification to the mobile OS that a key has been virtually pressed. The virtual keyboard application includes the specific key or character associated with the pressed area of the virtual keyboard.

Application Event Handling
Application Notification: The interrupt generated by the virtual keyboard application notifies the mobile OS of a "key pressed" event.

Focused Application: The mobile OS then forwards this event to the currently focused application, which could be a web browser or any other application where the user is inputting text.

Web Stack Interaction: In the context of the web stack, the web browser or web application receives the event. If a text input field is currently in focus, the browser's JavaScript can capture the "key pressed" event and process it accordingly. This allows users to interact with web forms or other web-based content using the virtual keyboard.


Interrupt fires [NOT for USB keyboards]
---------------------------------------

Hardware Components
Keyboard Interrupt Request Line (IRQ): The keyboard sends signals to its assigned Interrupt Request Line (IRQ), which is a hardware-level signal used to request the CPU's attention when an event, in this case, a keypress, occurs.

Interrupt Vector Mapping: The interrupt controller maps the keyboard's IRQ to an "interrupt vector," which is an integer identifier. This mapping ensures that the CPU can identify the source of the interrupt.

Interrupt Descriptor Table (IDT): The CPU uses the Interrupt Descriptor Table (IDT) to map interrupt vectors to specific functions known as "interrupt handlers." The IDT is a data structure in the operating system that associates interrupt vectors with their respective handlers.

Software Components
Kernel-supplied Interrupt Handlers: The operating system's kernel provides a set of interrupt handlers, including those for keyboard interrupts. These handlers are functions that are executed when specific interrupt vectors are triggered.

Interrupt Arrival: When an interrupt from the keyboard arrives, the CPU indexes the IDT using the associated interrupt vector. This process allows the CPU to identify the appropriate interrupt handler for the keyboard event.

Execution of Interrupt Handler: The CPU executes the interrupt handler associated with the keyboard interrupt. In this case, the keyboard interrupt handler is responsible for processing the keypress event.

Kernel Interaction
Kernel Entry: As the interrupt handler runs, it enters the kernel, which is the core of the operating system. The kernel has direct control over the hardware and can manage various aspects of the computer's operation.

Keyboard Event Processing: Within the kernel, the keyboard interrupt handler processes the incoming keyboard event. It translates the keypress into a keycode or character, which can be used by the operating system and applications.

Web Stack Interaction
Operating System Integration: In the context of the web stack, the operating system communicates the keyboard event to the currently focused application, which could be a web browser.

Web Browser Interaction: The web browser, which is part of the web stack, receives the keyboard event and processes it. If a text input field on a web page is in focus, the browser's JavaScript can capture the event and insert the corresponding character or keycode into the text input field.

(On Windows) A ``WM_KEYDOWN`` message is sent to the app
--------------------------------------------------------

Hardware to Software Interaction
Key Down Event: When a key is pressed, Windows generates a WM_KEYDOWN message, which serves as a notification to the application that a key has been pressed.

HID to Scancode: The Human Interface Device (HID) transport layer passes the key down event to the KBDHID.sys driver. This driver converts the HID usage into a scancode. In this case, the scancode corresponds to "VK_RETURN," represented as 0x0D.

KBDHID.sys to KBDCLASS.sys: The KBDHID.sys driver interfaces with the KBDCLASS.sys driver, which is responsible for handling keyboard and keypad input securely. It ensures that input from various devices is handled consistently and safely.

Kernel Mode Execution
Win32K.sys: The KBDCLASS.sys driver then calls into the Win32K.sys system component. This component operates in kernel mode, and its primary role is to manage the user interface for Windows applications.
Determining Active Window
GetForegroundWindow() API: Win32K.sys determines which window is currently active using the GetForegroundWindow() API. This API provides the window handle (hWnd) of the browser's address box or the focused element.

SendMessage API: Using the window handle obtained from GetForegroundWindow(), Windows calls the SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam) function. The SendMessage API adds the WM_KEYDOWN message to the message queue of the specific window, in this case, the browser's address box.

lParam Details: The lParam parameter in the SendMessage function provides additional information about the keypress. It contains a bitmask that includes the repeat count (which is 0 in this case), the actual scan code (for "VK_RETURN," it's 0x0D), and other details such as whether extended keys like Alt, Shift, or Ctrl were also pressed.

WindowProc and Message Processing
WindowProc: The window (represented by hWnd) that is currently active is typically an edit control in the browser, such as a text input field. The WindowProc associated with this control is a message processing function that handles various window-related messages.

WM_KEYDOWN Message Handler: Within the WindowProc, a message handler for WM_KEYDOWN messages is implemented. This handler examines the third parameter passed to SendMessage (wParam). In this case, because it's "VK_RETURN," it identifies that the user has pressed the "Enter" key.

User Interaction: The message handler processes the "Enter" keypress, typically by triggering an action based on the context. For example, in a web browser, it might submit a form or move to a new line in a text area.

(On OS X) A ``KeyDown`` NSEvent is sent to the app
--------------------------------------------------

The interrupt signal triggers an interrupt event in the I/O Kit kext keyboard
driver. The driver translates the signal into a key code which is passed to the
OS X ``WindowServer`` process. Resultantly, the ``WindowServer`` dispatches an
event to any appropriate (e.g. active or listening) applications through their
Mach port where it is placed into an event queue. Events can then be read from
this queue by threads with sufficient privileges calling the
``mach_ipc_dispatch`` function. This most commonly occurs through, and is
handled by, an ``NSApplication`` main event loop, via an ``NSEvent`` of
``NSEventType`` ``KeyDown``.

(On GNU/Linux) the Xorg server listens for keycodes
---------------------------------------------------

When a graphical ``X server`` is used, ``X`` will use the generic event
driver ``evdev`` to acquire the keypress. A re-mapping of keycodes to scancodes
is made with ``X server`` specific keymaps and rules.
When the scancode mapping of the key pressed is complete, the ``X server``
sends the character to the ``window manager`` (DWM, metacity, i3, etc), so the
``window manager`` in turn sends the character to the focused window.
The graphical API of the window  that receives the character prints the
appropriate font symbol in the appropriate focused field.

Parse URL
---------

* The browser now has the following information contained in the URL (Uniform
  Resource Locator):

    - ``Protocol``  "http"
        Use 'Hyper Text Transfer Protocol'

    - ``Resource``  "/"
        Retrieve main (index) page


Is it a URL or a search term?
-----------------------------

When no protocol or valid domain name is given the browser proceeds to feed
the text given in the address box to the browser's default web search engine.
In many cases the URL has a special piece of text appended to it to tell the
search engine that it came from a particular browser's URL bar.

Convert non-ASCII Unicode characters in the hostname
------------------------------------------------

* The browser checks the hostname for characters that are not in ``a-z``,
  ``A-Z``, ``0-9``, ``-``, or ``.``.
* Since the hostname is ``google.com`` there won't be any, but if there were
  the browser would apply `Punycode`_ encoding to the hostname portion of the
  URL.

Check HSTS list
---------------
* The browser checks its "preloaded HSTS (HTTP Strict Transport Security)"
  list. This is a list of websites that have requested to be contacted via
  HTTPS only.
* If the website is in the list, the browser sends its request via HTTPS
  instead of HTTP. Otherwise, the initial request is sent via HTTP.
  (Note that a website can still use the HSTS policy *without* being in the
  HSTS list.  The first HTTP request to the website by a user will receive a
  response requesting that the user only send HTTPS requests.  However, this
  single HTTP request could potentially leave the user vulnerable to a
  `downgrade attack`_, which is why the HSTS list is included in modern web
  browsers.)

DNS lookup
----------

* Browser checks if the domain is in its cache. (to see the DNS Cache in
  Chrome, go to `chrome://net-internals/#dns <chrome://net-internals/#dns>`_).
* If not found, the browser calls ``gethostbyname`` library function (varies by
  OS) to do the lookup.
* ``gethostbyname`` checks if the hostname can be resolved by reference in the
  local ``hosts`` file (whose location `varies by OS`_) before trying to
  resolve the hostname through DNS.
* If ``gethostbyname`` does not have it cached nor can find it in the ``hosts``
  file then it makes a request to the DNS server configured in the network
  stack. This is typically the local router or the ISP's caching DNS server.
* If the DNS server is on the same subnet the network library follows the
  ``ARP process`` below for the DNS server.
* If the DNS server is on a different subnet, the network library follows
  the ``ARP process`` below for the default gateway IP.


ARP process
-----------

In order to send an ARP (Address Resolution Protocol) broadcast the network
stack library needs the target IP address to lookup. It also needs to know the
MAC address of the interface it will use to send out the ARP broadcast.

The ARP cache is first checked for an ARP entry for our target IP. If it is in
the cache, the library function returns the result: Target IP = MAC.

If the entry is not in the ARP cache:

* The route table is looked up, to see if the Target IP address is on any of
  the subnets on the local route table. If it is, the library uses the
  interface associated with that subnet. If it is not, the library uses the
  interface that has the subnet of our default gateway.

* The MAC address of the selected network interface is looked up.

* The network library sends a Layer 2 (data link layer of the `OSI model`_)
  ARP request:

``ARP Request``::

    Sender MAC: interface:mac:address:here
    Sender IP: interface.ip.goes.here
    Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
    Target IP: target.ip.goes.here

Depending on what type of hardware is between the computer and the router:

Directly connected:

* If the computer is directly connected to the router the router response
  with an ``ARP Reply`` (see below)

Hub:

* If the computer is connected to a hub, the hub will broadcast the ARP
  request out of all other ports. If the router is connected on the same "wire",
  it will respond with an ``ARP Reply`` (see below).

Switch:

* If the computer is connected to a switch, the switch will check its local
  CAM/MAC table to see which port has the MAC address we are looking for. If
  the switch has no entry for the MAC address it will rebroadcast the ARP
  request to all other ports.

* If the switch has an entry in the MAC/CAM table it will send the ARP request
  to the port that has the MAC address we are looking for.

* If the router is on the same "wire", it will respond with an ``ARP Reply``
  (see below)

``ARP Reply``::

    Sender MAC: target:mac:address:here
    Sender IP: target.ip.goes.here
    Target MAC: interface:mac:address:here
    Target IP: interface.ip.goes.here

Now that the network library has the IP address of either our DNS server or
the default gateway it can resume its DNS process:

* The DNS client establishes a socket to UDP port 53 on the DNS server,
  using a source port above 1023.
* If the response size is too large, TCP will be used instead.
* If the local/ISP DNS server does not have it, then a recursive search is
  requested and that flows up the list of DNS servers until the SOA is reached,
  and if found an answer is returned.

Opening of a socket
-------------------
Once the browser receives the IP address of the destination server, it takes
that and the given port number from the URL (the HTTP protocol defaults to port
80, and HTTPS to port 443), and makes a call to the system library function
named ``socket`` and requests a TCP socket stream - ``AF_INET/AF_INET6`` and
``SOCK_STREAM``.

* This request is first passed to the Transport Layer where a TCP segment is
  crafted. The destination port is added to the header, and a source port is
  chosen from within the kernel's dynamic port range (ip_local_port_range in
  Linux).
* This segment is sent to the Network Layer, which wraps an additional IP
  header. The IP address of the destination server as well as that of the
  current machine is inserted to form a packet.
* The packet next arrives at the Link Layer. A frame header is added that
  includes the MAC address of the machine's NIC as well as the MAC address of
  the gateway (local router). As before, if the kernel does not know the MAC
  address of the gateway, it must broadcast an ARP query to find it.

At this point the packet is ready to be transmitted through either:

* `Ethernet`_
* `WiFi`_
* `Cellular data network`_

For most home or small business Internet connections the packet will pass from
your computer, possibly through a local network, and then through a modem
(MOdulator/DEModulator) which converts digital 1's and 0's into an analog
signal suitable for transmission over telephone, cable, or wireless telephony
connections. On the other end of the connection is another modem which converts
the analog signal back into digital data to be processed by the next `network
node`_ where the from and to addresses would be analyzed further.

Most larger businesses and some newer residential connections will have fiber
or direct Ethernet connections in which case the data remains digital and
is passed directly to the next `network node`_ for processing.

Eventually, the packet will reach the router managing the local subnet. From
there, it will continue to travel to the autonomous system's (AS) border
routers, other ASes, and finally to the destination server. Each router along
the way extracts the destination address from the IP header and routes it to
the appropriate next hop. The time to live (TTL) field in the IP header is
decremented by one for each router that passes. The packet will be dropped if
the TTL field reaches zero or if the current router has no space in its queue
(perhaps due to network congestion).

This send and receive happens multiple times following the TCP connection flow:

* Client chooses an initial sequence number (ISN) and sends the packet to the
  server with the SYN bit set to indicate it is setting the ISN
* Server receives SYN and if it's in an agreeable mood:
   * Server chooses its own initial sequence number
   * Server sets SYN to indicate it is choosing its ISN
   * Server copies the (client ISN +1) to its ACK field and adds the ACK flag
     to indicate it is acknowledging receipt of the first packet
* Client acknowledges the connection by sending a packet:
   * Increases its own sequence number
   * Increases the receiver acknowledgment number
   * Sets ACK field
* Data is transferred as follows:
   * As one side sends N data bytes, it increases its SEQ by that number
   * When the other side acknowledges receipt of that packet (or a string of
     packets), it sends an ACK packet with the ACK value equal to the last
     received sequence from the other
* To close the connection:
   * The closer sends a FIN packet
   * The other sides ACKs the FIN packet and sends its own FIN
   * The closer acknowledges the other side's FIN with an ACK

TLS handshake
-------------
* The client computer sends a ``ClientHello`` message to the server with its
  Transport Layer Security (TLS) version, list of cipher algorithms and
  compression methods available.

* The server replies with a ``ServerHello`` message to the client with the
  TLS version, selected cipher, selected compression methods and the server's
  public certificate signed by a CA (Certificate Authority). The certificate
  contains a public key that will be used by the client to encrypt the rest of
  the handshake until a symmetric key can be agreed upon.

* The client verifies the server digital certificate against its list of
  trusted CAs. If trust can be established based on the CA, the client
  generates a string of pseudo-random bytes and encrypts this with the server's
  public key. These random bytes can be used to determine the symmetric key.

* The server decrypts the random bytes using its private key and uses these
  bytes to generate its own copy of the symmetric master key.

* The client sends a ``Finished`` message to the server, encrypting a hash of
  the transmission up to this point with the symmetric key.

* The server generates its own hash, and then decrypts the client-sent hash
  to verify that it matches. If it does, it sends its own ``Finished`` message
  to the client, also encrypted with the symmetric key.

* From now on the TLS session transmits the application (HTTP) data encrypted
  with the agreed symmetric key.

If a packet is dropped
----------------------

Sometimes, due to network congestion or flaky hardware connections, TLS packets
will be dropped before they get to their final destination. The sender then has
to decide how to react. The algorithm for this is called `TCP congestion
control`_. This varies depending on the sender; the most common algorithms are
`cubic`_ on newer operating systems and `New Reno`_ on almost all others.

* Client chooses a `congestion window`_ based on the `maximum segment size`_
  (MSS) of the connection.
* For each packet acknowledged, the window doubles in size until it reaches the
  'slow-start threshold'. In some implementations, this threshold is adaptive.
* After reaching the slow-start threshold, the window increases additively for
  each packet acknowledged. If a packet is dropped, the window reduces
  exponentially until another packet is acknowledged.

HTTP protocol
-------------

If the web browser used was written by Google, instead of sending an HTTP
request to retrieve the page, it will send a request to try and negotiate with
the server an "upgrade" from HTTP to the SPDY protocol.

If the client is using the HTTP protocol and does not support SPDY, it sends a
request to the server of the form::

    GET / HTTP/1.1
    Host: google.com
    Connection: close
    [other headers]

where ``[other headers]`` refers to a series of colon-separated key-value pairs
formatted as per the HTTP specification and separated by single newlines.
(This assumes the web browser being used doesn't have any bugs violating the
HTTP spec. This also assumes that the web browser is using ``HTTP/1.1``,
otherwise it may not include the ``Host`` header in the request and the version
specified in the ``GET`` request will either be ``HTTP/1.0`` or ``HTTP/0.9``.)

HTTP/1.1 defines the "close" connection option for the sender to signal that
the connection will be closed after completion of the response. For example,

    Connection: close

HTTP/1.1 applications that do not support persistent connections MUST include
the "close" connection option in every message.

After sending the request and headers, the web browser sends a single blank
newline to the server indicating that the content of the request is done.

The server responds with a response code denoting the status of the request and
responds with a response of the form::

    200 OK
    [response headers]

Followed by a single newline, and then sends a payload of the HTML content of
``www.google.com``. The server may then either close the connection, or if
headers sent by the client requested it, keep the connection open to be reused
for further requests.

If the HTTP headers sent by the web browser included sufficient information for
the webserver to determine if the version of the file cached by the web
browser has been unmodified since the last retrieval (ie. if the web browser
included an ``ETag`` header), it may instead respond with a request of
the form::

    304 Not Modified
    [response headers]

and no payload, and the web browser instead retrieve the HTML from its cache.

After parsing the HTML, the web browser (and server) repeats this process
for every resource (image, CSS, favicon.ico, etc) referenced by the HTML page,
except instead of ``GET / HTTP/1.1`` the request will be
``GET /$(URL relative to www.google.com) HTTP/1.1``.

If the HTML referenced a resource on a different domain than
``www.google.com``, the web browser goes back to the steps involved in
resolving the other domain, and follows all steps up to this point for that
domain. The ``Host`` header in the request will be set to the appropriate
server name instead of ``google.com``.

HTTP Server Request Handle
--------------------------
The HTTPD (HTTP Daemon) server is the one handling the requests/responses on
the server-side. The most common HTTPD servers are Apache or nginx for Linux
and IIS for Windows.

* The HTTPD (HTTP Daemon) receives the request.
* The server breaks down the request to the following parameters:
   * HTTP Request Method (either ``GET``, ``HEAD``, ``POST``, ``PUT``,
     ``PATCH``, ``DELETE``, ``CONNECT``, ``OPTIONS``, or ``TRACE``). In the
     case of a URL entered directly into the address bar, this will be ``GET``.
   * Domain, in this case - google.com.
   * Requested path/page, in this case - / (as no specific path/page was
     requested, / is the default path).
* The server verifies that there is a Virtual Host configured on the server
  that corresponds with google.com.
* The server verifies that google.com can accept GET requests.
* The server verifies that the client is allowed to use this method
  (by IP, authentication, etc.).
* If the server has a rewrite module installed (like mod_rewrite for Apache or
  URL Rewrite for IIS), it tries to match the request against one of the
  configured rules. If a matching rule is found, the server uses that rule to
  rewrite the request.
* The server goes to pull the content that corresponds with the request,
  in our case it will fall back to the index file, as "/" is the main file
  (some cases can override this, but this is the most common method).
* The server parses the file according to the handler. If Google
  is running on PHP, the server uses PHP to interpret the index file, and
  streams the output to the client.

Behind the scenes of the Browser
----------------------------------

Once the server supplies the resources (HTML, CSS, JS, images, etc.)
to the browser it undergoes the below process:

* Parsing - HTML, CSS, JS
* Rendering - Construct DOM Tree → Render Tree → Layout of Render Tree →
  Painting the render tree

Browser
-------

The browser's functionality is to present the web resource you choose, by
requesting it from the server and displaying it in the browser window.
The resource is usually an HTML document, but may also be a PDF,
image, or some other type of content. The location of the resource is
specified by the user using a URI (Uniform Resource Identifier).

The way the browser interprets and displays HTML files is specified
in the HTML and CSS specifications. These specifications are maintained
by the W3C (World Wide Web Consortium) organization, which is the
standards organization for the web.

Browser user interfaces have a lot in common with each other. Among the
common user interface elements are:

* An address bar for inserting a URI
* Back and forward buttons
* Bookmarking options
* Refresh and stop buttons for refreshing or stopping the loading of
  current documents
* Home button that takes you to your home page

**Browser High-Level Structure**

The components of the browsers are:

* **User interface:** The user interface includes the address bar,
  back/forward button, bookmarking menu, etc. Every part of the browser
  display except the window where you see the requested page.
* **Browser engine:** The browser engine marshals actions between the UI
  and the rendering engine.
* **Rendering engine:** The rendering engine is responsible for displaying
  requested content. For example if the requested content is HTML, the
  rendering engine parses HTML and CSS, and displays the parsed content on
  the screen.
* **Networking:** The networking handles network calls such as HTTP requests,
  using different implementations for different platforms behind a
  platform-independent interface.
* **UI backend:** The UI backend is used for drawing basic widgets like combo
  boxes and windows. This backend exposes a generic interface that is not
  platform-specific.
  Underneath it uses operating system user interface methods.
* **JavaScript engine:** The JavaScript engine is used to parse and
  execute JavaScript code.
* **Data storage:** The data storage is a persistence layer. The browser may
  need to save all sorts of data locally, such as cookies. Browsers also
  support storage mechanisms such as localStorage, IndexedDB, WebSQL and
  FileSystem.

HTML parsing
------------

The rendering engine starts getting the contents of the requested
document from the networking layer. This will usually be done in 8kB chunks.

The primary job of the HTML parser is to parse the HTML markup into a parse tree.

The output tree (the "parse tree") is a tree of DOM element and attribute
nodes. DOM is short for Document Object Model. It is the object presentation
of the HTML document and the interface of HTML elements to the outside world
like JavaScript. The root of the tree is the "Document" object. Prior to
any manipulation via scripting, the DOM has an almost one-to-one relation to
the markup.

**The parsing algorithm**

HTML cannot be parsed using the regular top-down or bottom-up parsers.

The reasons are:

* The forgiving nature of the language.
* The fact that browsers have traditional error tolerance to support well
  known cases of invalid HTML.
* The parsing process is reentrant. For other languages, the source doesn't
  change during parsing, but in HTML, dynamic code (such as script elements
  containing `document.write()` calls) can add extra tokens, so the parsing
  process actually modifies the input.

Unable to use the regular parsing techniques, the browser utilizes a custom
parser for parsing HTML. The parsing algorithm is described in
detail by the HTML5 specification.

The algorithm consists of two stages: tokenization and tree construction.

**Actions when the parsing is finished**

The browser begins fetching external resources linked to the page (CSS, images,
JavaScript files, etc.).

At this stage the browser marks the document as interactive and starts
parsing scripts that are in "deferred" mode: those that should be
executed after the document is parsed. The document state is
set to "complete" and a "load" event is fired.

Note there is never an "Invalid Syntax" error on an HTML page. Browsers fix
any invalid content and go on.

CSS interpretation
------------------

* Parse CSS files, ``<style>`` tag contents, and ``style`` attribute
  values using `"CSS lexical and syntax grammar"`_
* Each CSS file is parsed into a ``StyleSheet object``, where each object
  contains CSS rules with selectors and objects corresponding CSS grammar.
* A CSS parser can be top-down or bottom-up when a specific parser generator
  is used.

Page Rendering
--------------

* Create a 'Frame Tree' or 'Render Tree' by traversing the DOM nodes, and
  calculating the CSS style values for each node.
* Calculate the preferred width of each node in the 'Frame Tree' bottom-up
  by summing the preferred width of the child nodes and the node's
  horizontal margins, borders, and padding.
* Calculate the actual width of each node top-down by allocating each node's
  available width to its children.
* Calculate the height of each node bottom-up by applying text wrapping and
  summing the child node heights and the node's margins, borders, and padding.
* Calculate the coordinates of each node using the information calculated
  above.
* More complicated steps are taken when elements are ``floated``,
  positioned ``absolutely`` or ``relatively``, or other complex features
  are used. See
  http://dev.w3.org/csswg/css2/ and http://www.w3.org/Style/CSS/current-work
  for more details.
* Create layers to describe which parts of the page can be animated as a group
  without being re-rasterized. Each frame/render object is assigned to a layer.
* Textures are allocated for each layer of the page.
* The frame/render objects for each layer are traversed and drawing commands
  are executed for their respective layer. This may be rasterized by the CPU
  or drawn on the GPU directly using D2D/SkiaGL.
* All of the above steps may reuse calculated values from the last time the
  webpage was rendered, so that incremental changes require less work.
* The page layers are sent to the compositing process where they are combined
  with layers for other visible content like the browser chrome, iframes
  and addon panels.
* Final layer positions are computed and the composite commands are issued
  via Direct3D/OpenGL. The GPU command buffer(s) are flushed to the GPU for
  asynchronous rendering and the frame is sent to the window server.

GPU Rendering
-------------

* During the rendering process the graphical computing layers can use general
  purpose ``CPU`` or the graphical processor ``GPU`` as well.

* When using ``GPU`` for graphical rendering computations the graphical
  software layers split the task into multiple pieces, so it can take advantage
  of ``GPU`` massive parallelism for float point calculations required for
  the rendering process.


Window Server
-------------

Post-rendering and user-induced execution
-----------------------------------------

After rendering has been completed, the browser executes JavaScript code as a result
of some timing mechanism (such as a Google Doodle animation) or user
interaction (typing a query into the search box and receiving suggestions).
Plugins such as Flash or Java may execute as well, although not at this time on
the Google homepage. Scripts can cause additional network requests to be
performed, as well as modify the page or its layout, causing another round of
page rendering and painting.

.. _`Creative Commons Zero`: https://creativecommons.org/publicdomain/zero/1.0/
.. _`"CSS lexical and syntax grammar"`: http://www.w3.org/TR/CSS2/grammar.html
.. _`Punycode`: https://en.wikipedia.org/wiki/Punycode
.. _`Ethernet`: http://en.wikipedia.org/wiki/IEEE_802.3
.. _`WiFi`: https://en.wikipedia.org/wiki/IEEE_802.11
.. _`Cellular data network`: https://en.wikipedia.org/wiki/Cellular_data_communication_protocol
.. _`analog-to-digital converter`: https://en.wikipedia.org/wiki/Analog-to-digital_converter
.. _`network node`: https://en.wikipedia.org/wiki/Computer_network#Network_nodes
.. _`TCP congestion control`: https://en.wikipedia.org/wiki/TCP_congestion_control
.. _`cubic`: https://en.wikipedia.org/wiki/CUBIC_TCP
.. _`New Reno`: https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_New_Reno
.. _`congestion window`: https://en.wikipedia.org/wiki/TCP_congestion_control#Congestion_window
.. _`maximum segment size`: https://en.wikipedia.org/wiki/Maximum_segment_size
.. _`varies by OS` : https://en.wikipedia.org/wiki/Hosts_%28file%29#Location_in_the_file_system
.. _`简体中文`: https://github.com/skyline75489/what-happens-when-zh_CN
.. _`한국어`: https://github.com/SantonyChoi/what-happens-when-KR
.. _`日本語`: https://github.com/tettttsuo/what-happens-when-JA
.. _`downgrade attack`: http://en.wikipedia.org/wiki/SSL_stripping
.. _`OSI Model`: https://en.wikipedia.org/wiki/OSI_model
.. _`Spanish`: https://github.com/gonzaleztroyano/what-happens-when-ES
